
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Comienzo del programa
Prueba:
		;colocamos el puntero de pila en la cima de la memoria
		MOVE #65535, .SP
		;reservamos el espacio para variables globales de clase en la pila
		SUB .SP, #4
		MOVE .A, .SP
		;guardamos en .IY el puntero a pila, para tener controladas las variables globales
		MOVE .SP, .IY
		;guardamos tambien en .IX el puntero a pila, para tener controlado siempre SP en las recursiones
		MOVE .SP, .IX
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

				MOVE #100, .R0
				MOVE .R0, #1[.IY]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Comienzo del ámbito main
main:
		;guardamos los registros en pila
		PUSH .IX
		PUSH .R0
		PUSH .R1
		PUSH .R2
		PUSH .R3
		PUSH .R4
		PUSH .R5
		PUSH .R6
		PUSH .R7
		PUSH .R8
		PUSH .R9
		;reservamos el espacio para variables locales en la pila
		SUB .SP, #2
		MOVE .A, .SP
		;salvamos el valor de .IY
		MOVE .IY, .R9
		;.IX apunta todavía al anterior marco de pila, lo usaremos para rescatar los parámetros (si hay)
		MOVE .IX, .IY
		;guardamos en .IX el puntero a pila, para usar este registro como índice de este método
		MOVE .SP, .IX
		;guardamos los parámetros pasados (si los hay) en sus respectivas variables locales
		;restauramos el valor de .IY
		MOVE .R9, .IY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

				MOVE #0, .R0
				MOVE .R0, #2[.IX]

bucle0:
				CMP #2[.IX], .R-1
				BN $etiq0
				MOVE #0, .R0
		BR $etiq1

etiq0:
				MOVE #1, .R0

etiq1:
				CMP .R0, #0
				BZ $fin-bucle0
				MOVE #1, .R0
ADD #1[.IY], .R0
MOVE .A, .R1				;PRUEBAS
				MOVE .R1, #1[.IY]
		BR $bucle0

fin-bucle0:
		;liberamos el espacio para variables globales
		ADD .SP, #4
		MOVE .A, .SP

		;Fin de la ejecución.
		HALT
