
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Comienzo del programa
Prueba:
		;colocamos el puntero de pila en la cima de la memoria
		MOVE #65535, .SP
		;reservamos el espacio para variables globales de clase en la pila
		SUB .SP, #3
		MOVE .A, .SP
		;guardamos en .IY el puntero a pila, para tener controladas las variables globales
		MOVE .SP, .IY
		;guardamos tambien en .IX el puntero a pila, para tener controlado siempre SP en las recursiones
		MOVE .SP, .IX
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

				MOVE #1, .R0
				MOVE .R0, #3[.IY]
				MOVE #2, .R0
				MOVE .R0, #1[.IY]
				MOVE #3, .R1
				MOVE .R1, #2[.IY]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Comienzo del ámbito main
main:
		;guardamos los registros en pila
		PUSH .IX
		PUSH .R0
		PUSH .R1
		PUSH .R2
		PUSH .R3
		PUSH .R4
		PUSH .R5
		PUSH .R6
		PUSH .R7
		PUSH .R8
		PUSH .R9
		;reservamos el espacio para variables locales en la pila
		SUB .SP, #1
		MOVE .A, .SP
		;salvamos el valor de .IY
		MOVE .IY, .R9
		;.IX apunta todavía al anterior marco de pila, lo usaremos para rescatar los parámetros (si hay)
		MOVE .IX, .IY
		;guardamos en .IX el puntero a pila, para usar este registro como índice de este método
		MOVE .SP, .IX
		;guardamos los parámetros pasados (si los hay) en sus respectivas variables locales
		;restauramos el valor de .IY
		MOVE .R9, .IY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

				MOVE #100, .R1
				MOVE #1, .R2
SUB .R1, .R2
MOVE .A, .R3				;PRUEBAS
				MOVE .R3, #3[.IY]
				MOVE #100, .R1
SUB .R1, #1[.IY]
MOVE .A, .R2				;PRUEBAS
				MOVE .R2, #1[.IY]
SUB #3[.IY], #1[.IY]
MOVE .A, .R1				;PRUEBAS
SUB .R1, #2[.IY]
MOVE .A, .R2				;PRUEBAS
				MOVE .R2, #2[.IY]
		;liberamos el espacio para variables globales
		ADD .SP, #3
		MOVE .A, .SP

		;Fin de la ejecución.
		HALT
